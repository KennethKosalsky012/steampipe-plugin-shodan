package shodan

import (
	"context"
	"time"

	"github.com/shadowscatcher/shodan/search"

	"github.com/turbot/steampipe-plugin-sdk/grpc/proto"
	"github.com/turbot/steampipe-plugin-sdk/plugin"
	"github.com/turbot/steampipe-plugin-sdk/plugin/transform"
)

func tableShodanExploit(ctx context.Context) *plugin.Table {
	return &plugin.Table{
		Name:             "shodan_exploit",
		Description:      "List the exploits requested for this account.",
		DefaultTransform: transform.FromJSONTag(),
		List: &plugin.ListConfig{
			Hydrate:    listExploit,
			KeyColumns: plugin.SingleColumn("query"),
		},
		// NOTE: GetExploit returns less data fields than ListExploits, and I believe
		// this API is normally going to have a small number of results. So, the
		// get has not been implemented at this time.
		Columns: []*plugin.Column{
			// Top columns
			{Name: "query", Type: proto.ColumnType_STRING, Hydrate: queryString, Transform: transform.FromValue(), Description: "Query string for the exploit search."},
			{Name: "id", Type: proto.ColumnType_STRING, Transform: transform.FromField("Id"), Description: "Unique ID for the exploit/vulnerability."},
			// Other columns
			{Name: "source", Type: proto.ColumnType_STRING, Description: "The name of the data source. Possible values are: CVE, ExploitDB, Metasploit."},
			{Name: "code", Type: proto.ColumnType_STRING, Description: "The actual code of the exploit."},
			{Name: "author", Type: proto.ColumnType_STRING, Description: "The author of the exploit/vulnerability."},
			{Name: "bid", Type: proto.ColumnType_JSON, Transform: transform.FromField("BID"), Description: "The Bugtraq ID for the exploit."},
			{Name: "cve", Type: proto.ColumnType_JSON, Transform: transform.FromField("CVE"), Description: "The Common Vulnerability and Exposures ID for the exploit."},
			{Name: "date", Type: proto.ColumnType_STRING, Description: "Date when the exploit was released."},
			{Name: "description", Type: proto.ColumnType_STRING, Description: "The description of the exploit, how it works and where it applies."},
			{Name: "msb", Type: proto.ColumnType_JSON, Transform: transform.FromField("MSB"), Description: "The Microsoft Security Bulletin ID for the exploit."},
			{Name: "osvdb", Type: proto.ColumnType_JSON, Transform: transform.FromField("OSVDB"), Description: "The Open Source Vulnerability Database ID for the exploit."},
			{Name: "platform", Type: proto.ColumnType_JSON, Transform: transform.FromField("Platform").Transform(transform.EnsureStringArray), Description: "The operating system that the exploit targets."},
			{Name: "port", Type: proto.ColumnType_INT, Description: "The port number for the affected service if the exploit is remote."},
			{Name: "title", Type: proto.ColumnType_STRING, Description: "The title or short description for the exploit if available."},
			{Name: "type", Type: proto.ColumnType_STRING, Description: "The type of exploit."},
			{Name: "alias", Type: proto.ColumnType_JSON, Description: "Alias for the exploit."},
			{Name: "rank", Type: proto.ColumnType_STRING, Description: "Rank for the exploit."},
			{Name: "arch", Type: proto.ColumnType_JSON, Description: "Architecture for the exploit."},
			{Name: "privileged", Type: proto.ColumnType_BOOL, Description: "True if the exploit is privileged."},
			{Name: "version", Type: proto.ColumnType_STRING, Description: "Version of the exploit."},
		},
	}
}

func queryString(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	quals := d.KeyColumnQuals
	q := quals["query"].GetStringValue()
	return q, nil
}

func listExploit(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	conn, err := connect(ctx, d)
	if err != nil {
		plugin.Logger(ctx).Error("shodan_exploit.listExploit", "connection_error", err)
		return nil, err
	}
	quals := d.KeyColumnQuals
	q := quals["query"].GetStringValue()
	params := search.ExploitParams{Query: search.ExploitsQuery{Text: q}, Page: 1}
	count := 0
	for params.Page <= 10 {
		start := time.Now()
		result, err := conn.ExploitSearch(ctx, params)
		plugin.Logger(ctx).Warn("shodan_exploit.listExploit", "query_time", time.Since(start))
		if err != nil {
			plugin.Logger(ctx).Error("shodan_exploit.listExploit", "query_error", err)
			break
			//return nil, err
		}
		plugin.Logger(ctx).Warn("shodan_exploit.listExploit", "total", result.Total, "count", count, "len", len(result.Matches), "page", params.Page, "result", result)
		// Silly, but the only way I can see to decide we are at the last page
		/*
			if len(result.Matches) == 0 {
				break
			}
		*/
		for _, i := range result.Matches {
			d.StreamListItem(ctx, i)
			count++
		}
		if count >= result.Total {
			break
		}
		params.Page++
	}
	return nil, nil
}
